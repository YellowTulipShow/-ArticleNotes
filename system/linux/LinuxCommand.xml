<?xml version="1.0" encoding="utf-8"?>
<!-- Linux常用命令 -->
http://man.linuxde.net

<文件操作命令>
	<ls notes="查看文件">
		<-l notes="显示文件或目录(文件夹)详细属性">
			如:/etc/passwd 文件
			-rw-r--r-- 		1 		root 	root 		1888	2013-01-10 		/etc/passwd
			类型和权限	  文件数	用户	用户组	 文件大小	修改时间		文件名

			类型：
				-:表示一个普通的文件
				d:表示一个目录
				l:表示一个符号链接文件,实际上它指向另一个文件
				b:表示区块设备文件,特殊类型的文件
				c:表示其他的外围设备文件,也是特殊类型的文件
				s/p:这些文件关系到系统的数据结构和管道,通常很少见到.

			权限：
				r:表示读取权限
				w:表示写入权限
				x:表示执行权限

			目录权限：
				（在目录中的权限,x(执行)的权限是最重要的!）
				x:权限表示当前的目录(文件夹)是否可以使用cd命令进去,
				rx:可以执行cd和ls命令
				wx:可以执行cd、touch(创建文件)、rm、vi(自己的文件或别人的文件)
				wxt:可以执行cd、touch、rm、vi(可以执行自己的文件,但是别人的文件不行)


			<链接 src="http://www.cnblogs.com/avril/archive/2010/03/23/1692809.html"></链接>
		</-l>
		<-a notes="显示所有文件(包括隐藏文件)">
			使用"."号开头的文件为隐藏文件(需要使用"ls -a"查看)
		</-a>
		<-F>显示文件类型</-F>
	</ls>
	<umask notes="由umask值来确定创建文件或目录的默认权限">
	{
		作用是在当前用户创建文件或目录时,当做掩码的作用换算出创建文件或目录的初始权限
		每个用户建立文件时,此文件都会有默认权限
		默认权限的值由环境中的umask值来确定
		用户可以自主改动umask值,并在改动后建立的文件上得到体现
		一般用户的默认umask值为002,系统用户的默认umask值为022
	}
		比如-默认情况下:
		root用户的umask为0022
			那么root用户创建的文件默认权限是:666-022=644:-rw-r--r--
			并且root用户创建的目录默认权限是:777-022=755:drwxr-xr-x
		普通用户的umask为0002
			那么普通用户创建的文件默认权限是:666-002=664:-rw-rw-r--
			并且普通用户创建的目录默认权限是:777-002=775:drwxrwxr-x
	</umask>
	<file notes="显示制定文件的类型">
		例如：
			[...]# find /etc/passwd
			/etc/passwd: ASCII text
			// (表示这个文件是ascii码类型的文本文档)
	</file>
	<mv notes="移动或重命名文件">
		// 将/etc目录下的passwd文件移动到/tmp目录下,并且改名为aaa
		[...]# mv /etc/passwd /tmp/aaa
	</mv>
	<cp notes="拷贝文件">
		-r	// 用于操作文件夹,此参数也可用于别的命令
	</cp>
	<rm notes="执行删除操作">
		-i	// 使用交互式操作(询问用户是否删除,在默认使用的rm命令情况下,默认使用)
		-r	// 用于操作文件夹
		-f	// 忽略不存在的文件,没有提示
	</rm>
	<touch notes="创建空文件或更新文件时间(注意不是文件夹)"></touch>
	<pwd notes="查看当前所在的路径"></pwd>
	<du notes="用来查看文件的实际占用大小，大小为kB为单位"></du>
	<chmod notes="用于更改设置文件或目录的权限"></chmod>
	<wc notes="用于打印文件的文本行数、单词数、字节数等"></wc>
	<cat notes="查看文件内容"></cat>
	<more notes="逐屏查看文件内容"></more>
	<less notes="★(zrq推荐使用less)逐屏查看文件内容"></less>
	<head notes="查看文本的前十行"></head>
	<tail notes="查看文本的后十行">
		-f		用于"监听":可以用于"盯着"一个文件的后十行,一旦这个文件的内容产生变化,tail命令的输入结果也随之发生变化,一般可以用来看日志文件
	</tail>
	<diff notes="检查制定的不同文件的区别">
		例如：
			// 检查a.txt和b.txt文件的区别
			diff a.txt b.txt
	</diff>
	<patch notes="用于为开放源代码软件安装补丁程序"></patch>
	<pwd notes="查看当前路径"></pwd>
	<cd notes="改变当前路径"></cd>
	<mkdir notes="创建新目录(创建文件夹)">
		-p			// 递归创建路径path上的所有文件夹   mkdir -p path
	</mkdir>
	<rmdir notes="删除空目录(删除一个空文件夹)"></rmdir>
	<rm notes="删除文件或目录">
		-r			// 递归删除目录和文件及其内容
		-f			// 不进行提示
		-i			// 进行任何删除操作前必须先确认
	</rm>

	搜索命令的集合:(不同的文件中,不同的场景使用的搜索命令都不尽相同)
	<which notes="主要用于查找可执行文件(可执行的命令)">
		[...]# which ls
		alias ls='ls --color=tty'
				/bin/ls
		// 从中可以看出,使用which命令可以查看这个可执行命令的路径,
		可以查看到底执行了那个可执行文件

	注意:which命令查找的路径是一些基本上固定下来的路径,
	只能在这些路径中进行查找,具体的路径:
		[...]# echo $PATH  // 查看固定路径
	所以这个which命令主要用于查找这些可执行的文件(可执行的命令)
	</which>
	<whereis notes="作用和which命令差不多,路径多了一些而已"></whereis>
	<slocate notes="根据数据库查找'所有'文件">
		locate命令是这个命令的软链接

		这个命令是用来查找所有的文件的命令,不过是根据[数据库]进行查找
		这个数据库是这个命令单独的数据库
		当这个数据库的文件数据目录没有更新的时候,是查不到新添加的文件的路径的
		更新数据库的命令:
			[...]# updatedb
		所以updatedb和slocate命令是相互配对的一组命令

		每天凌晨4:02分系统自动执行updatedb

		在Linux的日常计划中每天都要执行：/etc/cron.daily/目录下的所有文件
		其中slocate.cron文件其中这句话：
			/us/bin/updatedb
		这样，那么在每天都会执行这行代码，也就是更新数据库
	</slocate>
	<updatedb notes="更新数据库的命令(与slocate配套出现)"></updatedb>
	<find notes="用于查找指定目录下的所有文件">
		基本语法：
		find [路径] [参数] [表达式]
		从指定路径下递归向下搜索文件
		支持按照各种条件方式搜索
		支持对搜索得到的文件进一步用指令操作

		例如：从根目录开始查找一个名称为[newfile.txt]的文件
			[...]# find / -name newfile.txt
			(查找名称里有[newfile]的文件)
			[...]# find / -name "*newfile*"

		(这里的参数放前面)
		用于查找ls -l命令能列举出的属性作为根据的文件
		<-name notes="根据文件名寻找文件"></-name>
		<-user notes="根据文件拥有者寻找文件">
			例如:
				find /home -user shrek
		</-user>
		<-group notes="根据文件所属组寻找文件">
			例如:
				find /home -group shrek
		</-group>
		<-type notes="根据文件类型寻找文件">
			类型根据ls命令中的文件类型中第一个字符确定
			例如:
				find /home -type d
			不过注意:普通文件的类别是f而不是显示的-
		</-type>
		<-perm notes="根据文件权限寻找文件">
			例如:
				// 表示在/home目录下，查找文件权限九个字符中有一个是指定的字符就可以
				find /home -perm +755

				// 表示在/home目录下，查找文件权限九个字符中必须大于或等于指定的权限类型
				find /home -perm -444

			实例:
			当需要检查当前系统安全之类的时候
		</-perm>
		<-size notes="根据文件大小寻找文件">
				// 可以按照文件长度来查找文件，这里所指的文件长度既可以用块（block）来计量，也可以用字节来计量。
				// 以字节计量文件长度的表达形式为N c；以块计量文件长度只用数字表示即可。
				// 在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，因为这时使用块来计量更容易转换。
				例如：
					// 在当前目录下查找文件长度大于1 M字节的文件
					find . -size +1000000c -print

					// 在/home/apache目录下查找文件长度恰好为100字节的文件:
					find /home/apache -size 100c -print

					// 在当前目录下查找长度超过10块的文件（一块等于512字节）
					find . -size +10 -print
		</-size>
		<-mtime notes="查找指定的时间">
				// 如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。
				// 如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件。
				// 用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件.
			例如:
				// 希望在系统根目录下查找更改时间在5日以内的文件，可以用：
				find / -mtime -5 -print

				//为了在/var/adm目录下查找更改时间在3日以前的文件，可以用:
				find /var/adm -mtime +3 -print
		</-mtime>



		(这里的参数可以放置在中间)
		<-a notes="表示[and]和的意思,可以用于连接不同的查找条件">
			例如:
				// 查询/home目录下所属用户是shrek并且所属组是shrek的文件,并且显示详细信息
				find /home -user shrek -a -group shrek -ls
		</-a>
		<-o notes="表示[or]或的意思,可以用于连接不同的查找条件">
			例如:
				// 查找/home目录下所属用户是shre或者文件类型是d目录的文件
				find /home -user shrek -o -type d
		</-o>


		(这里的参数放后面)
		<-ls notes="可以将查询出来的东西直接使用ls -l命令显示">
			例如：
				[...]# find /etc -name "*network*" -ls
		</-ls>
		<-exec notes="可以在之后写入需要执行的程序">
			例如：
			// 在/etc目录下查找名字有"network"的文件作为目标,执行file命令(shell中详细讲解file {} \;这种格式)
				find /etc -name "*network*" -exec file {} \;

			// 在/home目录下查找名字有"network"的文件作为目标,执行删除操作
				find /home -name "*network*" -exec rm {} \;
		</-exec>
		<-ok notes="功能与-exec相同,增加询问操作,防止误操作"></-ok>
		<-print notes="输出标准流"></-print>

	</find>
	<grep notes="在文件中搜索指定字符内容，返回行的内容或者文件名">
		grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。
		来自: http://man.linuxde.net/grep
		-a 不要忽略二进制数据。 -A<显示列数/> 除了显示符合范本样式的那一行之外，并显示该行之后的内容。
		-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。
		-c 计算符合范本样式的列数。
		-C	<显示列数/>或-<显示列数/> 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
		-d	<进行动作/> 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。
		-e	<范本样式/> 指定字符串作为查找文件内容的范本样式。
		-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。
		-f	<范本文件/> 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。
		-F 将范本样式视为固定字符串的列表。
		-G 将范本样式视为普通的表示法来使用。
		-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
		-H 在显示符合范本样式的那一列之前，标示该列的文件名称。
		-i 忽略字符大小写的差别。
		-l 列出文件内容符合指定的范本样式的文件名称。
		-L 列出文件内容不符合指定的范本样式的文件名称。
		-n 在显示符合范本样式的那一列之前，标示出该列的编号。
		-q 不显示任何信息。
		-R/-r 此参数的效果和指定“-d recurse”参数相同。
		-s 不显示错误信息。
		-v 反转查找。
		-w 只显示全字符合的列。
		-x 只显示全列符合的列。
		-y 此参数效果跟“-i”相同。
		-o 只输出文件中匹配到的部分。
		例如：
			// 在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：
			grep match_pattern file_name
			grep "match_pattern" file_name
	</grep>

	压缩工具
	<gzip notes="用于压缩文件,扩展名为:[.gz]">
		gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。
		gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。
		gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。
		据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。

		基本语法：
		gzip [选项] [参数]

		-a或——ascii：使用ASCII文字模式；
		-d或--decompress或----uncompress：解开压缩文件；
		-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；
		-h或——help：在线帮助；
		-l或——list：列出压缩文件的相关信息；
		-L或——license：显示版本与版权信息；
		-n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；
		-N或——name：压缩文件时，保存原来的文件名称及时间戳记；
		-q或——quiet：不显示警告信息；
		-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；
		-S或（压缩字尾字符串）或----suffix（压缩字尾字符串）：更改压缩字尾字符串；
		-t或——test：测试压缩文件是否正确无误；
		-v或——verbose：显示指令执行过程；
		-V或——version：显示版本信息；
		-（压缩效率）：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；
		--best：此参数的效果和指定“-9”参数相同；
		--fast：此参数的效果和指定“-1”参数相同。
	</gzip>
	<gunzip notes="解压缩gzip命令产生的文件"></gunzip>
	<bzip2 notes="比gzip更高压缩比例的压缩命令,扩展名为:[.bz2]">
		基本语法：
		bzip2 [选项] [参数]

		-c或——stdout：将压缩与解压缩的结果送到标准输出；
		-d或——decompress：执行解压缩；
		-f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；
		-h或——help：在线帮助；
		-k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；
		-s或——small：降低程序执行时内存的使用量；
		-t或——test：测试.bz2压缩文件的完整性；
		-v或——verbose：压缩或解压缩文件时，显示详细的信息；
		-z或——compress：强制执行压缩；
		-V或——version：显示版本信息；
		--repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；
		--repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。
	</bzip2>
	<bunzip2 notes="解压缩bzip2命令产生的文件"></bunzip2>
	<zip notes="在windows系统下的压缩的zip文件可以用这个搞"></zip>
	<unzip notes="解压缩zip命令产生的文件"></unzip>

	打包
	<tar notes="打包文件(备份)">
		<概念>
			tar命令可以为linux的文件和目录创建档案。
			利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。
			tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。
			利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。
			首先要弄清两个概念：打包和压缩。
			打包是指将一大堆文件或目录变成一个总的文件；
			压缩则是将一个大的文件通过一些压缩算法变成一个小文件。

			为什么要区分这两个概念呢？
			这源于Linux中很多压缩程序只能针对一个文件进行压缩，
			这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），
			然后再用压缩程序进行压缩（gzip bzip2命令）。
		</概念>

		基本语法：
		tar [选项] [参数]

		-A或--catenate：新增文件到以存在的备份文件；
		-B：设置区块大小；
		-c或--create：建立新的备份文件；
		-C （目录）：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。
		-d：记录文件的差别；
		-x或--extract或--get：从备份文件中还原文件；
		-t或--list：列出备份文件的内容；
		-z或--gzip或--ungzip：通过gzip指令处理备份文件；
		-Z或--compress或--uncompress：通过compress指令处理备份文件；
		-f（备份文件）或--file=（备份文件）：指定备份文件；
		-v或--verbose：显示指令执行过程；
		-r：添加文件到已经压缩的文件；
		-u：添加改变了和现有的文件到已经存在的压缩文件；
		-j：支持bzip2解压文件；
		-v：显示操作过程；
		-l：文件系统边界设置；
		-k：保留原有文件不覆盖；
		-m：保留文件不被覆盖；
		-w：确认压缩文件的正确性；
		-p或--same-permissions：用原来的文件权限还原文件；
		-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；
		-N （日期格式） 或 --newer=（日期时间）：只将较指定日期更新的文件保存到备份文件里；
		--exclude=（范本样式）：排除符合范本样式的文件。

		例如：
			// 将文件全部打包为tar包
			tar -cvf log.tar log2012.log 仅打包，不压缩！
			tar -zcvf log.tar.gz log2012.log 打包后，以 gzip 压缩
			tar -jcvf log.tar.bz2 log2012.log 打包后，以 bzip2 压缩

			// 将tar包解压缩
			tar -zxvf /opt/soft/test/log.tar.gz

			其实最简单的使用 tar 就只要记忆底下的方式即可：
				压　缩：tar -jcv -f filename.tar.bz2 [要被压缩的文件或目录名称 ]
				查　询：tar -jtv -f filename.tar.bz2
				解压缩：tar -jxv -f filename.tar.bz2 -C [欲解压缩的目录]

			// 将/home/shrek目录下的文件备份到/dev/st0第一个的中(这种备份操作经常用到)
			tar -cvf /dev/st0 /home/shrek
	</tar>

</文件操作命令>

<系统命令>
	<vi notes="编辑查看文件">
		分屏启动<Vim>
			// 使用大写的O参数来垂直分屏。
			[...]# vim -On file1 file2 ...
			// 使用小写的o参数来水平分屏。
			[...]# vim -on file1 file2 ...
		# 注释: n是数字，表示分成几个屏。
		</Vim>
		<历史or特点>
			在linux历史中,ed是最早时的编辑器,是非可视化模式,并且不会显示要编辑的内容
			之后是sed,可以显示要编辑的内容文本,但需要单独的命令才能进行操作编辑
			现如今版本:
			vi	/bin/vi
			vim /usr/bin/vim
			默认是执行的vim,vim(Vi IMproved) vim是vi的升级版,具有更多的实用功能
			更加强大的编辑器工具: emacs  制作者: richard stallman

			当我们需要在每次启动vim时都需要启动某些命令时:
			使用命令vim ~/.vimrc 在这个文件中添加需要每次启动时自动执行的命令
		</历史or特点>

		<命令模式>
			i/I/a/A/o/O/s/S	// 进入<insert编辑模式>
				i 		// 在当前光标所在地进入insert模式
				I 		// 在当前光标所在行移动到头部进入insert模式
				a		// 在当前光标所在的下一个字符进入insert模式
				A 		// 在当前光标所在行移动到末尾进入insert模式
				o 		// 在当前光标所在行之下新开一行进入insert模式
				O 		// 在当前光标所在行之上新开一行进入insert模式
				s 		// 删除当前光标选中的字符进入insert模式,相当于 i + Delete键
				S		// 删除当期行进入insert模式
				Esc		// 退出insert编辑模式
			</insert编辑模式>
			r [char]			// 用于替换掉当前的字符 将结果替换为[char]

			0 					// 移动光标到当前行的头部
			$ 					// 移动光标到当前行的末尾

			w 					// 每次移动一个单词
			G					// 移动光标到文件的最后一行
			[n] G				// 移动光标到行号为[n]的哪一行上
			Ctrl键 G 			// 显示当前光标所在行的信息

			[ or ]				// 跳段操作

			x 					// 删除一个字符
			[n]					// 删除[n]个字符
			dw					// 删除一个以当前光标为开头的单词
			[n]dw				// 删除[n]个单词
			dd					// 删除当前行,也是就是剪切操作,可以用p粘贴
			[n]dd				// 删除[n]行

			r 					// 替换当前光标所在字符
			R					// 一直执行替换操作,知道使用Esc退出Replace替换模式

			yy					// 复制当前行
			[n]yy				// 复制[n]行,以当前行为第一行
			p 					// 粘贴复制的内容

			"[name][n]yy		// 可以执行将这[n]行内容复制到剪贴板[name]
			"[name]p 			// 在需要粘贴的时候,从剪贴板中取出[name]的内容

			u					// 撤销上一步的操作
			Ctrl键 r 			// 将u撤销的步骤取消撤销

			/ or ?				// 查找,可以通过n和Ctrl n进行下一个和上一个的查找

			综上所有的代码,规律:
			在命令模式下:
			在任意代码之前输入数字如3,那么之后执行任意代码都会执行3次,以此类推
		</命令模式>

		<行模式>
			:w					// 保存操作
			:w [filename]		// 将当前文档的内容另存为[filename]的文件名,(加 >> 是将内容追加到这个文件中)
			:[n],[x] w >> [filename]	// 从[n]到[x]行，将内容追加到[filename]文件中
			:q 					// 退出操作

			:[n]				// 跳转到数字[n]行
			:r [filename]		// 读取命令 （读取一个文件的内容）
			:e [filename]		// 用于更改另外的文件
			:e!					// 将当前文档恢复成最初的状态
			:e! [filename]		// 放弃当前的更改,直接却修改文件
			:[n],[x]s/[原本]/[新]/g		// 从[n]到[x]进行替换，将[原本]替换成[新] g:并且不用询问直接替换,c:单个执行替换询问
			:s/[旧]/[新]		// 替换字符串

			:sh					// 新建一个shell执行命令,当输入exit时就返回了

			:![命令]			// 执行[命令]这个命令

			:set number			// 显示行号
			:set reler			// 显示正文行号
			:set autoindent		// 正文自动缩进
			:set option			// 设置选项为option
            :exit               // 直接退出
		</行模式>
	</vi>
	<sed notes="主要用来自动编辑一个或多个文件的内容,主要用于shell编程">
		sed是一种流编辑器，它是文本处理中非常中的工具，
		能够完美的配合正则表达式使用，功能不同凡响。
		处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），
		接着用sed命令处理缓冲区中的内容，
		处理完成后，把缓冲区的内容送往屏幕。
		接着处理下一行，这样不断重复，直到文件末尾。
		文件内容并没有 改变，除非你使用重定向存储输出。
		Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。

		-e 					// 之后用于执行执行的命令,一般需要用到正则表达式
		s/.../...1			// 用于替换操作: ... 替换为 ...1
		s/.../...1/g		// 在行中不管有多少个相同内容都替换,如果不加只是替换第一个
		-n					// 默认不进行打印,只是用于打印后面带有条件的筛选出来的行
<!--	'/\<shrek\>/p'	--> // p表示打印一般要和-n结合使用:表示将行中有shrek单词的行打印出来
		'/bash/d'			// d删除:将内容有bash这个单词的行删除掉

		基本实例:
			// 将文件当中的所有root替换为shrek
			sed -e 's/root/shrek/g' /etc/passwd

			// 行中有bash的行执行删除操作
			sed -e '/bash/d' /etc/passwd

			// 只输出打印符合行中有shrek单词的行,其他行不显示
<!--		sed -n -e '/\<shrek\>/p' /etc/passwd 				-->

			// 行中有shrek单词的行执行bash替换为nologin,不显示
<!--		sed -n -e '/\<shrek\>/s/bash/nologin/' /etc/passwd    -->

			// 行中有shrek单词的行执行bash替换为nologin,显示更改的行
<!--		sed -n -e '/\<shrek\>/s/bash/nologin/p' /etc/passwd    -->

			// 行中shrek单词的行执行所有bash替换为nologin
<!--		sed -e '/\<shrek\>/s/bash/nologin/g' /etc/passwd -->

			// 在文件中将所有#开头的和全是空格的行执行删除操作
			sed -e '/^#/d' -e '^$/d' /etc/squid/squid.conf

			// 行中有bash的行执行全部shrek替换为root的操作
			sed -e '/bash/s/shrek/root/g' /etc/passwd

	</sed>
	<awk notes="比sed更加强大的一种编辑,处理文本工具(可以列操作)">
		awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。
		数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。
		它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。
		它在命令行中使用，但更多是作为脚本来使用。
		awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。

		实例:
			// chkconfig --list // 这个命令是用来查看服务运行级别的
			// 通过awk命令筛选出内容并换行输出:	第一行 = 第五行
			chkconfig --list | awk '{print $1 " = " $5}'

	</awk>
	<man notes="查看命令帮助文档">
		<q>退出帮助文档</q>
	</man>
	<info notes="查看命令实例帮助文档"></info>
	<alias notes="创建别名命令">
		可用通过alias命令来创建一个命令,并能使用 如:
		[...]# alias ii='ls -l'
		[...]# ii //当使用这个命令的时候,就相当于执行了ls -l这个命令
		[...]# unalias ii //unalias命令是用来对应alias的,是删除别名命令

		[...]# vi ~/.bashrc
		在vi编辑器中编辑配置文件,可以把自定义的别名命令添加进去
	</alias>
	<echo notes="显示内容(在编程中用于显示变量之类的值)">
		[...]# echo 一些内容 // 在结果处就是显示"一些内容"
		[...]# echo $USER // 显示当前用户的名称
		[...]# AAA=jlkjsdfisjfl // 创建一个变量"AAA"
		[...]# echo $AAA // 显示AAA的内容:jlkjsdfisjfl
		[...]# echo AAA // 就是显示AAA

		-n 		// 不换行输出,跟printf类似了
		-e 		// 若字符串出现<特殊字符>,则特别加以处理,而不会将它当成一般字符输出
					\a 发出警告声；
					\b 删除前一个字符；
					\c 最后不加上换行符号；
					\f 换行但光标仍旧停留在原来的位置；
					\n 换行且光标移至行首；
					\r 光标移至行首，但不换行；
					\t 插入tab；
					\v 与\f相同；
					\\ 插入\字符；
					\nnn 插入nnn（八进制）所代表的ASCII字符；

					$echo -e "a\bdddd"
					dddd

					$echo -e "a\adddd" //输出同时会发出报警声音
					adddd


					$echo -e "a\ndddd" //自动换行
					a
					dddd
		</特殊字符>
	</echo>
	<shutdown notes="关机">
		-a notes="Use /etc/shutdown.allow."
		-c	// 中断关机：当执行"shutdown -h 12:00"指令时，只要按+键就可以中断关机的指令
		-f	// 重新启动时不进行磁盘检测（fsck）
		-F	// 重新启动时进行磁盘检测（fsck）
		-h	// 关闭电源
		-k	// 模拟关机（不是真的关机），只是向登录者发送警告信息出去！
		-n	// 不调用init进程进行关机，而是强行关机
		-r	// 关闭系统然后重新启动，类似于Windows平台restart
		-t	// 延迟关机的时间
		-w	// 仅做测试，并不真的将系统重新开机，只会把重开机的数据写入/var/log目录下的wtmp记录文件
	注意:别忘了打 now 立刻命令
	</shutdown>
	<init notes="用于设置系统状态">
		[...]# init 0	// 停机（千万不能把initdefault 设置为0 ）
		[...]# init 1	// 单用户模式
		[...]# init 2	// 多用户，没有 NFS
		[...]# init 3	// 完全多用户模式(标准的运行级)
		[...]# init 4	// 没有用到
		[...]# init 5	// 在命令行模式下,打开图形用户界面X11 （xwindow)
		[...]# init 6	// 重新启动 （千万不要把initdefault 设置为6 ）
		vi /etc/inittab		// 设置系统启动配置文件(可以配置启动时是否启动x-windows:(5为启动,3为不启动)(第一句))
	</init>

	<hostname notes="显示/设置主机"></hostname>
	<uname notes="显示系统信息(内核版本/编译信息)"></uname>
	<last notes="显示最近的用户登录"></last>
	<lastlog notes="显示每个用户的登录情况"></lastlog>
	<id notes="显示用户的信息"></id>
	<w notes="命令用于显示已经登陆系统的用户列表，并显示用户正在执行的指令。">
		执行这个命令可得知目前登入系统的用户有那些人，以及他们正在执行的程序。单独执行w命令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。
	</w>
	<history notes="调用出历史[操作]记录">
		History命令主要用于显示历史指令记录内容, 下达历史纪录中的指令 。
		<[1]History命令语法>
			[test@linux]# history [n]
			[test@linux]# history [-c]
			[test@linux]# history [-raw] histfiles
			参数：
			n   ：数字,要列出最近的 n 笔命令列表
			-c  ：将目前的shell中的所有 history 内容全部消除
			-a  ：将目前新增的history 指令新增入 histfiles 中，若没有加 histfiles ，
			则预设写入 ~/.bash_history
			-r  ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中
			-w  ：将目前的 history 记忆内容写入 histfiles
			Linux系统当你在shell(控制台)中输入并执行命令时，shell会自动把你的命令记录到历史列表中，
			一般保存在用户目录下的.bash_history文件中。默认保存1000条，你也可以更改这个值。
			如果你键入 history, history会向你显示你所使用的前1000个历史命令，并且给它们编了号，
			你会看到一个用数字编号的列表快速从屏幕上卷过。你可能不需要查看1000个命令中的所有项目,
			当然你也可以加入数字来列出最近的 n 笔命令列表。
			linux中history命令不仅仅让我们可以查询历史命令而已. 我们还可以利用相关的功能来帮我们执行命令。
		</[1]History命令语法>
		<[2]运行特定的历史命令>
			history会列出bash保存的所有历史命令，并且给它们编了号，我们可以使用“叹号接编号”的方式运行特定的历史命令.
			语法说明:
			[test@linux]# [!number]  [!command] [!!]
			参数说明：
			number   ：第几个指令的意思；
			command  ：指令的开头几个字母
			!        ：上一个指令的意思！
		</[2]运行特定的历史命令>
		<[3]History命令实战>
			列出所有的历史记录：
			[test@linux] # history
			只列出最近10条记录：
			[test@linux] # history 10 (注,history和10中间有空格)
			使用命令记录号码执行命令,执行历史清单中的第99条命令
			[test@linux] #!99 (!和99中间没有空格)
			重复执行上一个命令
			[test@linux] #!!
			执行最后一次以rpm开头的命令(!?  ?代表的是字符串,这个String可以随便输，Shell会从最后一条历史命令向前搜索，最先匹配的一条命令将会得到执行。)
			[test@linux] #!rpm
			逐屏列出所有的历史记录：
			[test@linux]# history | more
			立即清空history当前所有历史命令的记录
			[test@linux] #history -c
			除了使用history命令,在 shell 或 GUI 终端提示下，你也可以使用上下方向键来翻阅命令历史(向下箭头会向前翻阅)，直到你找到所需命令为止。这可以让我们很方便地编辑前面的某一条命令，而不用重复输入类似的命令。
			History命令的用途确实很大！但需要小心安全的问题!尤其是 root 的历史纪录档案，这是黑客们的最爱！因为不小心的 root 会将很多的重要资料在执行的过程中会被纪录在 ~/.bash_history 当中，如果这个档案被解析的话，后果不堪设想
		</[3]History命令实战>

		小技巧:永久清空history历史记录:
		[...]# history -c
		[...]# history -w

		使用!加上命令历史的命令数字可以用来调用

		<制作指定的[命令记录器]>
			有时候记错了命令就输入错误命令，系统也记录了，一两条到时没什么，
			但是多了，就看的眼花，所以我们要清除那些错误的，又要保存正确的命令，一下是看到网上的一个方法，感觉挺不错的。
			一般情况下，删除命令记录的命令是"history -c"，前提是命令大部分是记载与/root/.bash_history这个文件，
			所以你vi查看，就会发现，即使用了"history -c"，你的命令还是记录在这个文件里，

			解决步骤如下:
			1.   建立一个文件来存储常用命令,   例如/root/history.txt,把常用命令当成文本写进去,每个命令占一行
			2.   在终端运行history   -c,   清除杂乱的历史记录,
			3.   运行   history   -r   /root/history.txt   ,   把命令读进来作为当前bash的历史记录
			4.   运行   history,   就得到一个整洁的命令列表了,   例如:
				[root@localhost   windata]#   history   -c
				[root@localhost   windata]#   history   -r   /root/history.txt
				[root@localhost   windata]#   history
				1     history   -r   /root/history.txt
				2     mount   -t   msdos   -o   iocharset=gb2312   /dev/sda1   /mnt/usb
				3     mount   -t   vfat   -o   iocharset-gb2312   /dev/hda5   /mnt/windata
				4     umount   /mnt/windata
				5     mount   -t   vfat   -o   iocharset-gb2312   /dev/hda5   /mnt/windata
				6     cd   /mnt/windata
				7     history
				[root@localhost   windata]#
			5.   以后命令乱了,   重复1-4的步骤,   又可以使命令很清晰了
		</制作指定的[命令记录器]>
	</history>
	<free notes="查看内存的使用情况"></Free>
	<df notes="查看硬盘使用情况"></df>
	<du notes="查看文件大小(当然也可以查看目录)"></du>
	<mount notes="用于加载文件系统指定的加载点">
		此命令最常用于挂载cdrom,使我们可以访问cdrom中的数据,
		因为你将光盘插入cdrom中,Linux并不会自动挂载,必须使用Linux mount命令来手动完成挂载

		mount -t auto /dev/cdrom /mnt/cdrom
	</mount>
	<strace notes="是一个集诊断、调试、统计与一体的工具(查看某些东西)"></strace>
	<sudo notes="用于暂时暂时使用别的用户的身份来执行命令,预设为root">
		在/etc/sudoers中设置了可执行sudo指令的用户。
		若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。

	</sudo>

	进程和作业管理:
	<top notes="可以实时查看系统的整体运行情况">
		是一个综合了多方信息监测系统性能和运行信息的实用工具.
		通过top命令所提供的互动式界面,用热键管理

		命令参数:
			-b：以批处理模式操作；
			-c：显示完整的治命令；
			-d：屏幕刷新间隔时间；
			-I：忽略失效过程；
			-s：保密模式；
			-S：累积模式；
			-i [时间]：设置间隔时间；
			-u [用户名]：指定用户名；
			-p [进程号]：指定进程；
			-n [次数]：循环显示的次数。

		交互式命令:
			h：显示帮助画面，给出一些简短的命令总结说明；
			k：可以执行kill命令(其中就可以杀死指定的进程)
			i：忽略闲置和僵死进程，这是一个开关式命令；
			q：退出程序；
			r：重新安排一个进程的优先级别；
			S：切换到累计模式；
			s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；
			f或者F：从当前显示中添加或者删除项目；
			o或者O：改变显示项目的顺序；
			l：切换显示平均负载和启动时间信息；
			m：切换显示内存信息；
			t：切换显示进程和CPU状态信息；
			c：切换显示命令名称和完整命令行；
			M：根据驻留内存大小进行排序；
			P：根据CPU使用百分比大小进行排序；
			T：根据时间/累计时间进行排序；
			w：将当前设置写入~/.toprc文件中。
			n: 跳高或者调低进程的优先级

		实例:
			top - 09:44:56 up 16 days, 21:23, 1 user, load average: 9.59, 4.75, 1.92
			Tasks: 145 total, 2 running, 143 sleeping, 0 stopped, 0 zombie
			Cpu(s): 99.8%us, 0.1%sy, 0.0%ni, 0.2%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st
			Mem: 4147888k total, 2493092k used, 1654796k free, 158188k buffers
			Swap: 5144568k total, 	56k used, 5144512k free, 2013180k cached

			PID  USER  PR  NI  VIRT  RES  SHR  S  %CPU  %MEM     TIME+  COMMAND
		   2559  root  14  -1 32344  11m 2444  S   7.2   4.4  28:15:38  X

		解释：
			top - 09:44:56[当前系统时间],
			16 days[系统已经运行了16天],
			1 user[个用户当前登录],
			load average: 9.59, 4.75, 1.92[系统负载(任务队列的平均长度)三个值分别为1分钟、5分钟、15分钟前到现在的平均值【这三个一般会小于1，如果持续高于5，请仔细查看那个程序影响系统的运行】”]

			Tasks: (任务信息总览)
			145 total[总进程数],
			2 running[正在运行的进程数],
			143 sleeping[睡眠的进程数],
			0 stopped[停止的进程数],
			0 zombie[冻结进程数(僵尸进程数)],

			Cpu(s): (CPU信息总览)
			99.8%us[用户空间占用CPU百分比],
			0.1%sy[内核空间占用CPU百分比],
			0.0%ni[用户进程空间内改变过优先级的进程占用CPU百分比],
			0.2%id[空闲CPU百分比],
			0.0%wa[等待输入输出的CPU时间百分比],
			0.0%hi[CPU服务于硬件中断所耗费的时间总额],
			0.0%si[CPU服务软中断所耗费的时间总额],
			0.0%st[Steal Time (截断时间总额?)],

			Mem: (分配信息总览)
			4147888k total[物理内存总量],
			2493092k used[使用的物理内存总量],
			1654796k free[空闲内存总量],
			158188k buffers[缓冲区内存总量]

			Swap: (交换信息总览)
			5144568k total[交换区总量],
			56k used[使用的交换区总量],
			5144512k free[空闲交换区总量],
			2013180k cached[缓冲的交换区总量],


			PID:进程ID编号
			USER:所属用户
			PR:优先级
			NI:<nice notes="其表示进程可被执行的优先级的修正数值">
				如前面所说，PRI值越小越快被执行，那么加入nice值后，
				将会使得PRI变为：PRI(new)=PRI(old)+nice。
				这样，当nice值为负值的时候，那么该程序将会优先级值将变小，
				即其优先级会变高，则其越快被执行。
				nice值的范围是:-20~19之间的整数，取值越高，优先级越低，默认为0

				到目前为止，更需要强调一点的是，
				进程的nice值不是进程的优先级，他们不是一个概念，
				但是进程nice值会影响到进程的优先级变化。

				调整nice的两个命令:
				<nice notes="一开始执行程序就指定nice值">
					nice -n -5 /usr/local/mysql/bin/mysqld_safe &
				</nice>
				<renice notes="调整已存在进程的nice值">
					renice -5 -p 5200
					#PID为5200的进程nice设为-5
				</renice>
			</nice>
			VIPT:虚拟内存大小
			RES:实际内存大小(进程使用的未被换出的物理内存)
			SHR:共享内存的大小
			S:进程状态  S(sleep睡眠) T(stop停止) R(run运行) D(Deep sleep深度睡眠) Z(zombie僵尸进程)
			%CPU:进程占用的CPU百分比
			%MEM:占用内存百分比
			TIME+:进城使用CPU累计的CPU时间
			COMMAND:执行的命令
	</top>
	<ps notes="也可以用来查看进程(ps命令的参数加-和不加-是完全不同的意思)">
		ps命令用于报告当前系统的进程状态。
		可以搭配kill指令随时中断、删除不必要的程序。
		ps命令是最基本同时也是非常强大的进程查看命令，
		使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，
		总之大部分信息都是可以通过执行该命令得到的。

		命令参数:
			-a：显示所有终端机下执行的程序，除了阶段作业领导者之外。
			a：显示现行终端机下的所有程序，包括其他用户的程序。
			-A：显示所有程序。
			-c：显示CLS和PRI栏位。
			c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。
			-C [指令名称]：指定执行指令的名称，并列出该指令的程序的状况。
			-d：显示所有程序，但不包括阶段作业领导者的程序。
			-e：此选项的效果和指定"A"选项相同。
			e：列出程序时，显示每个程序所使用的环境变量。
			-f：显示UID,PPIP,C与STIME栏位。
			f：用ASCII字符显示树状结构,表达程序间的相互关系(显示父子关系)
			-g [群组名称]：此选项的效果和指定"-G"选项相同，当亦能使用阶段作业领导者的名称来指定。
			g：显示现行终端机下的所有程序，包括群组领导者的程序。
			-G [群组识别码]：列出属于该群组的程序的状况，也可使用群组名称来指定。
			h：不显示标题列。
			-H：显示树状结构，表示程序间的相互关系。
			-j或j：采用工作控制的格式显示程序状况。
			-l或l：采用详细的格式来显示程序状况。
			L：列出栏位的相关信息。
			-m或m：显示所有的执行绪。
			n：以数字来表示USER和WCHAN栏位。
			-N：显示所有的程序，除了执行ps指令终端机下的程序之外。
			-p [程序识别码]：指定程序识别码，并列出该程序的状况。
			p [程序识别码]：此选项的效果和指定"-p"选项相同，只在列表格式方面稍有差异。
			r：只列出现行终端机正在执行中的程序。
			-s [阶段作业]：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。
			s：采用程序信号的格式显示程序状况。
			S：列出程序时，包括已中断的子程序资料。
			-t [终端机编号]：指定终端机编号，并列出属于该终端机的程序的状况。
			t [终端机编号]：此选项的效果和指定"-t"选项相同，只在列表格式方面稍有差异。
			-T：显示现行终端机下的所有程序。
			-u [用户识别码]：此选项的效果和指定"-U"选项相同。
			u：以用户为主的格式来显示程序状况。
			-U [用户识别码]：列出属于该用户的程序的状况，也可使用用户名称来指定。
			U [用户名称]：列出属于该用户的程序的状况。
			v：采用虚拟内存的格式显示程序状况。
			-V或V：显示版本信息。
			-w或w：采用宽阔的格式来显示程序状况。　
			x：显示所有程序，不以终端机来区分(显示后台进程)
			X：采用旧式的Linux i386登陆格式显示程序状况。
			-y：配合选项"-l"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。
			- [程序识别码]：此选项的效果和指定"p"选项相同。
			--cols [每列字符数]：设置每列的最大字符数。
			--columns [每列字符数]：此选项的效果和指定"--cols"选项相同。
			--cumulative：此选项的效果和指定"S"选项相同。
			--deselect：此选项的效果和指定"-N"选项相同。
			--forest：此选项的效果和指定"f"选项相同。
			--headers：重复显示标题列。
			--help：在线帮助。
			--info：显示排错信息。
			--lines [显示列数]：设置显示画面的列数。
			--no-headers：此选项的效果和指定"h"选项相同，只在列表格式方面稍有差异。
			--group [群组名称]：此选项的效果和指定"-G"选项相同。
			--Group [群组识别码]：此选项的效果和指定"-G"选项相同。
			--pid [程序识别码]：此选项的效果和指定"-p"选项相同。
			--rows [显示列数]：此选项的效果和指定"--lines"选项相同。
			--sid [阶段作业]：此选项的效果和指定"-s"选项相同。
			--tty [终端机编号]：此选项的效果和指定"-t"选项相同。
			--user [用户名称]：此选项的效果和指定"-U"选项相同。
			--User [用户识别码]：此选项的效果和指定"-U"选项相同。
			--version：此选项的效果和指定"-V"选项相同。
			--widty [每列字符数]：此选项的效果和指定"-cols"选项相同。

		例如:
			// 显示所有进程
			[...]# ps aux
			或者 	[...]# ps -ef

	</ps>
	<kill notes="杀掉关闭进程">
	-a：当处理当前进程时，不限制命令名和进程号的对应关系；
	-l [信息编号]：若不加[信息编号]选项，则-l参数会列出全部的信息名称；
	-p：指定kill 命令只打印相关进程的进程号，而不发送任何信号；
	-s [信息名称或编号]：指定要送出的信息；
	-u：指定用户。

		HUP		1		终端断线
		INT 	2		中断（同 Ctrl + C）
		QUIT 	3		退出（同 Ctrl + \）
		TERM 	15		终止(默认使用)
		KILL	9		强制终止(注意:不要常用,容易牵扯子进程的控制问题)
		CONT	18		继续（与STOP相反， fg/bg命令）
		STOP	19		暂停（同 Ctrl + Z）

		例如:
			[...]# ps -ef | grep vim
			root 3268 2884 0 16:21 pts/1 00:00:00 vim install.log
			root 3370 2822 0 16:21 pts/0 00:00:00 grep vim

			// 使用9号信号强制杀掉PID是3370的进程
			[...]# kill -9 3370

			[...]# kill 3268
			[...]# kill 3268
			-bash: kill: (3268) - 没有那个进程

	</kill>
	<killall notes="使用进程的名称来杀死进程，使用此指令可以杀死一组同名进程。">
		-e：对长名称进行精确匹配；
		-l：忽略大小写的不同；
		-p：杀死进程所属的进程组；
		-i：交互式杀死进程，杀死进程前需要进行确认；
		-l：打印所有已知信号列表；
		-q：如果没有进程被杀死。则不输出任何信息；
		-r：使用正规表达式匹配要杀死的进程名称；
		-s：用指定的进程号代替默认信号“SIGTERM”；
		-u：杀死指定用户的进程。
	</killall>
	<skill notes="可以用于杀掉指定的进程（可以包括名字）"></skill>
	<pstree notes="以树型的方式显示所有的进程(父子进程)"></pstree>
	在执行命令最后加符号:& 即是变为后台任务(包含进程)
	当操作一个进程时,输入进程号的时候需加符号: %
	杀掉后台进程---可以使用:
		// 杀掉任务号是1的任务,任务当中的进程即全部被杀
		[...]# kill %1
	<jobs notes="用于显示Linux中的任务列表及任务状态,包括后台运行的任务"></jobs>
	<fg notes="将后台任务调至前台运行">
		例如:
			// 将任务号: 3 的任务调至前台运行
			[...]# fg %3
	</fg>
	<bg notes="激活后台暂停的进程"></bg>
	<nohup notes="可以将程序以忽略挂起信号的方式运行起来(可以说是直接隶属于init父进程的子进程)">
		被运行的程序输出信息将不会显示到终端
		无论是否将此命令(nohup)的输出重定向到终端,
		输出的结果都将附加到当前目录的nohup.out文件中.
	</nohup>

	<tee notes="可以将数据重定向到指定文件和屏幕上(可以理解为一根管子又开了一个出口)">
		用于将数据重定向到文件,另一方面还可以提供一份重定向数据的副本作为后续命令的stdin

		例如:
			// 用ls命令列举出/etc目录下的文件,并且从结果中找出l类型的链接文件,
			// 通过tee命令复制一个结果到filename文件,并且将这份结果通过wc -l命令统计出有多少行.
			// 最终可以知道/etc目录下有多少链接文件,在filename文件中有这些文件的详细信息
			ls -l /etc | grep '^l' | tee [filename] | wc -l
	</tee>
	<tr notes="可以对来自标准输入的字符进行替换,压缩和删除">
		它可以将一组字符变成另一组字符,经常用来编写优美的单行命令,作为很强大
		字符集1：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；
		字符集2：指定要转换成的目标字符集。

		例如:
			[...]# echo "HELLO WORLD" | tr 'A-Z' 'a-z'
			hello world
	</tr>

	网络:
	<ifconfig notes="查看ip地址(注意命令写法:ifconfig )"></ifconfig>
	$ifconfig		 显示网络接口以及相应的IP地址。ifconfig可用于设置网络接口
	$ifup eth0     运行eth0接口
	$ifdown eth0   关闭eth0接口
	$iwconfig      显示无线网络接口
	$route         显示路由表。route还可以用于修改路由表
	$netstat       显示当前的网络连接状态
	$ping IP       发送ping包到地址IP
	$traceroute IP 探测前往地址IP的路由路径
	$dhclient      向DHCP主机发送DHCP请求，以获得IP地址以及其他设置信息。
	$host domain   DNS查询，寻找域名domain对应的IP
	$host IP       反向DNS查询
	$wget url      使用wget下载url指向的资源
	$wget -m url   镜像下载
</系统命令>

<Shell>
	Bash:
		<bash内部命令>
			alias 		// 设置bash别名
			unalias		// 删除已定义的别名
			cd			// 改变当前工作目录
			exit		// 终止shell
			export		// 使变量的值对当前shell的所有子进程都可见
			fc			// 用来编辑历史命令列表里的命令
			bg			// 使一个被挂起的进程在后台继续执行
			fg			// 使一个被挂起的进程在前台继续执行
			help 		// 显示bash内部命令的帮助信息
			kill 		// 终止某个进程
			pwd			// 显示当前工作目录
			seq			// 执行一个数字范围,返回范围的所有数值 seq 1 100 (列举1到100的所有整数)
			pgrep		// 以名称为依据从运行进程队列中查找进程,并显示查找到的进程id
			unset 		// 可以用于消除定义的变量和函数,命令后面直接加一个空格加名称:如:unset Myfunction
		</bash内部命令>
		<bash变量>
			set 		// set命令可以查看bash中的所有变量
			<unset notes="删除一个变量"></unset>
			[...]#AAA="aaa"		// 定义了一个局部变量AAA(只在当前shell中有效)
			export AAA		// 将局部变量改变为全局变量
			注意:bash当中的全局变量只是适用于当前的bash和相应的子bash,不能应用于父bash
			<env notes="用于显示环境变量"></env>
			// 执行脚本文件时,都是默认打开一个新的bash,所有如果脚本中有需要用到变量,需全局

			在~/.bash_profile文件中可以修改其bash启动的默认初始化文件
			PATH=$PATH:[目录]		// 可以将这个[目录]中的命令文件添加默认执行当中
		</bash变量>
		<bash命令历史>
			history命令可查询历史操作命令
			命令历史中的命令可以被调用
			.bash_history中的命令数目有HISTFILESIZE这个变量决定
			history表储存在内存内.用户logout时会记录到用户主目录中.bash_history文件
		</bash命令历史>
		<bash运算符>
			?		// 表示一个任意字符
			& 		// 丢入后台
			~		// 主目录
			#		// 注释
			$		// 表示变量
			%		// 任务标识前缀,表示任务,进程
			;		// 分隔符,先执行前面命令,在执行后面的命令,命令结束
			()		// 加上()表示声明函数
			{a,b,c}	// 表示将a,b,c全部表示一遍,枚举
			"" 		// 只屏蔽空格特殊意义
			''		// 全部屏蔽字符特殊意义
			``		// 反引号1键左边的键,在这其中可以先执行一个命令
			[ -判断 内容 ]		// 中括号前后两边各加上一个空格表示:判断内容,返回0(true)或1(false)
				-f 		// 判断文件
				-d		// 判断目录
				-l 		// 判断链接
				-b 		// 判断设备文件
				-x		// 判断是否是可以执行的文件
				-r 		// 判断是不是可以读的文件
				-w 		// 判断是不是可以写的文件
			&&		// 执行前面的判断语句,true执行false不执行
			||		// 与&&功能相同,结果相反,true不执行
			 = 		// 等号两边加空格,表示C#符号:  == 是否相等
			$[ ]	// 其中表示需要进行算术运算,返回数值结果
			( )		// 将其中命令打包到新开子bash中执行
		</bash运算符>
		<bash的执行脚本顺序>
			/etc/profile		// 不区分用户,只是在启动完整的bash时执行,比如新开一个tty,登录时执行
				/etc/profile.d/*.sh		// 一些常用的设置都在这些脚本中,各个子系统下的初始化脚本文件
			~/.bash_profile		// 区分用户,只是在启动完整的bash时执行
			~/.bashrc			// 区分用户,只要创建bash就执行
			/etc/bashrc			// 不区分用户,只要创建bash就执行
			........
			~/.bash_logout
		</bash的执行脚本顺序>

	Shell脚本编程
		第一行：
			文件的第一行是用来书写使用那种shell来执行之后的代码的！
			所有第一行的#号不代表是用来写注释的
			常见书写:
			#!/bin/sh
			#!/bin/bash

		使用命令:[...]# man bash
		查询bash下的命令参数...的使用方法

		可以使用参数来传递内容：
			$1 $2 $3
			不同的参数有一些内置为不同的含义:
			如:
				$1 		// 代表第一个参数
				$2 		// 代表第二个参数
				...
				$#		// 代表一共输入了几个参数
				$?		// 用于询问上一个操作或者命令是否执行成功:成功(0),不成功(非0)
				$$		// 表示此进程的PID

		可以使用命令来进行交互：
			-read		// 读入数据给变量(需要添加-p参数)
				read -p "This is AAA=" AAA		// (最后的AAA是传入的参数)
			-echo		// 输出数据
			-printf		// 输出数据

		脚本执行:
		1.使用路径:如:
		(需要执行权限,新开bash执行)
			./hello.sh
			/tmp/hello.sh
			注意:使用路径会新建一个虚拟控制台执行这个脚本文件,但不一定是bash,至少显示的不是
				也就是说当设置变量时,不能使用前两种方法执行脚本,因为在父bash无法读子bash设置的变量

		2.使用bash
		(no 权限,新开bash执行)
			如:bash ./hello.sh
			注意:使用bash会新建一个bash虚拟控制台来执行这个脚本

		3.使用:点+空格+路径
		(no 权限,当前bash执行)
			如:(. /tmp/zrq/hello.sh)

		流程控制: (好习惯:使用unset命令将使用过的变量消除)
			条件判断:
				-[  ] && ||		// 用于true和false的判断
					进行判断时的运算符:(满足下面要求的返回true)<value>
					1.关于文本判断:
						-e file 	// 文件 file 已经存在
						-f file		// 文件 file 是普通文件
						-s file 	// 文件 file 大小不为零
						-d file 	// 文件 file 是一个目录
						-r file 	// 文件 file 对当前用户可以读取
						-w file 	// 文件 file 对当前用户可以写入
						-x file 	// 文件 file 对当前用户可以执行
						-g file 	// 文件 file GID标志被设置
						-u file 	// 文件 file 的UID标志被设置
						-O file 	// 文件 file 是属于当前用户的
						-G file 	// 文件 file 的组ID和当前用户相同
						file1 -nt file2 	// 文件 file1 比 file2 更新
						file1 -ot file2 	// 文件 file1 比 file2 更老

					2.数值比较时的运算符:
						相同 -eq =
						不同 -ne !=
						大于 -gt
						小于 -lt
						大于或等于 -ge
						小于或等于 -le
						为空 -z
						不为空 -n
						比如:
							比较变量a和变量b的值是否相等就写作:[ $a = $b ]
							判断变量a是否为空就写作: [ -z $a ]
							判断整数变量a是大于b就写作: [ $a -gt $b ]

					</value>

				-if <explain>
				******************************
					if [ $AAA = 'shrek' ]
						then
						echo 'Hello shrek!'
						echo 'nice to meet you!'
					elif [ $AAA = 'root' ]
						then
						echo 'Hello root!'
						echo 'I miss you so much!'
					else
						printf 'get out here!'
					fi
				******************************
				注意:bash里的if语句then必须另开一行
				</explain>
				-case <explain>
				******************************
					case $AAA in
						shrek )
							echo 'Hello shrek!'
							echo 'nice to meet you!'
							;;
						root )
							echo 'Hello root!'
							echo 'I miss you so much!'
							;;
						* )
							echo 'get out here!'
							;;
					esac
				******************************
				</explain>
			循环:
				-while <explain> bash的while用法基本相同,只不过因为for的用法不同了,基本上数字运算的循环需要这个while来实现了
				******************************
					iii = 0
					while [ $iii -lt 100 ]
					do
						iii = $[$iii + 1]	// 这里的$[]用于算术运算定义的
						echo -n "$iii"
					done

					解释:
					表示当变量iii小于100时,执行iii加1,并不换行输出iii的值
				******************************
				</explain>
				-utile <explain> utile是while的相反判断,就是说utile是判断是否false执行循环体的,而传统意义上的while和for之类的是:是否为true执行循环体
				******************************
					iii = 0
					utile [ $iii -gt 100 ]
					do
						iii = $[$iii + 1]
						echo -n "$iii"
					done
				******************************
				</explain>
				-for <explain> bash的for实际用法相当于C#和java的foreach的用法
				******************************
					for i in 111 222 333 /etc/profile.d/*.sh
					do
						echo $i
					done

					seq实例:<example>
						#!/bin/bash

						for i in `seq 1 100`
						do
							echo -n "$i "
							sleep 1
						done

						实例解释:
							首先使用for循环获取到seq命令传入的1到100的所有整数
							通过echo -n 命令不停地输出这些数值
							sleep 1 的意思是停止1秒
					</example>
				******************************
				</explain>
				-break 		// 用于中断
				-continue

		bash -vx [ScriptFile]	// 用于在bash中进行调试,显示执行过程

		Bash中的函数: (定义:)
		Myfunction() {
			// 函数体
		}
		使用:
		Myfunction	// 直接使用名称就可以了

		取消函数使用:
		unset myfunction

		编程中可以使用 sed 和 awk 来自动编辑更改文件的内容
			可以使用到日志的分析上

</Shell>

<用户和组命令>
	<用户>
		<链接>
			Linux 中将用户添加到组的指令:http://cnzhx.net/blog/linux-add-user-to-group/
		</链接>
		<useradd notes="创建用户"></useradd>
		<userdel notes="删除用户"></userdel>
		<usermod notes="更改管理用户账户属性信息"></usermod>
		<passwd notes="管理密码">
			当忘记root密码时,机器还在身边是可以执行如下操作重置密码:
				1.重启计算机,按[“e”]键进入GRUB界面在引导装载程序菜单上，
				2.用上下键将光标放在用上下方向键选择你忘记密码的linux系统键入[“e”]键 来进入编辑模式
				3.同样的方法选择kernel内核,按[“e”]键进行下一步
				4.然后在编辑界面rhgb quiet后面加“空格”，然后键入“single”，或者直接输入数字的“1”并回车确定。
				5.回车后，按“b”键启动进入单用户模式，在这里修改root的密码。
				6.正常的使用passwd命令修改指定"用户"的密码 例如: passwd root
		</passwd>

	</用户>
	<组>
		<groupadd notes="创建组"></groupadd>
		<groupdel notes="删除组"></groupdel>
		<chgrp notes="改变文件或目录所属的组">
		　　语法：chgrp ［选项］ group filename?
		　　该命令改变指定指定文件所属的用户组。其中group可以是用户组ID，也可以是/etc/group文件中用户组的组名。文件名是以空格分开的要改变属组的文件列表，支持通配符。如果用户不是该文件的属主或超级用户，则不能改变该文件的组。
		　　该命令的各选项含义为：
		　　- R 递归式地改变指定目录及其下的所有子目录和文件的属组。
		　　例1：$ chgrp - R book /opt/local /book
		　　改变/opt/local /book/及其子目录下的所有文件的属组为book。
		</chgrp>	　　
		<chown notes="更改某个文件或目录的属主和属组。">
			这个命令也很常用。例如root用户把自己的一个文件拷贝给用户xu，为了让用户xu能够存取这个文件，root用户应该把这个文件的属主设为xu，否则，用户xu无法存取这个文件。
		　　语法：chown ［选项］ 用户或组 文件
		　　说明：chown将指定文件的拥有者改为指定的用户或组。用户可以是用户名或用户ID。组可以是组名或组ID。文件是以空格分开的要改变权限的文件列表，支持通配符。
		　　该命令的各选项含义如下：
		　　- R 递归式地改变指定目录及其下的所有子目录和文件的拥有者。
		　　- v 显示chown命令所做的工作。
		　　例1：把文件shiyan.c的所有者改为wang。
		　　$ chown wang shiyan.c
		　　例2：把目录/his及其下的所有文件和子目录的属主改成wang，属组改成users。
		　　$ chown - R wang.users /his
		</chown>
	</组>
</用户和组命令>

<正则表达式>
	' '			// 单引号：用于将单引号之间的内容保持原样，不会因为内容被Shell误识
	*			// 星号：
							1、代替表示任意字符
							2、任意多个前面的字符（将其前面的一个字符无限重复）
	,			// 英文逗号：用于匹配范围  例如：'.\{40,50\}' 匹配单个字符40次以上到50次
	.			// 英文句号：
							1、当前、本地的意思
							2、任意一个字符
	( )			// 英文小括号：创建一个用于匹配的String字符串
	$			// 金钱符号：以这个符号结尾的意思 例如：grep 'shrek$' [filename] // 在[filename]文件中查找行中以shrek内容结尾的行
	^			// 以这个符号为开头的意思 例如：grep '^shrek' [filename] // 在[filename]文件中查找行中以shrek内容开头的行
	\			// 脱意符：使用这个字符将其他的字符含义去除  例如：\* // 将*字符的寓意去除
<!--  \<  \>	// 匹配单词的开头和结尾（这两个字符可以拆分使用）  例如：\<s..k\>  // 将一个以s开头中间有两个字符并以k结尾的单词匹配出来-->
	\{  \}		// 将指定内容匹配指定次数  例如：a\{18\} // 将a这个字符匹配18次
	[ ]			// 匹配中括号中的指定的任意字符(如果在[ ]中加^符号代表反向选择)：例如：grep '^[abc]' /etc/passwd	// 将文件passwd当中的所有以a或b或c开头的行筛选出来

	实例:
		.		// 表示任何一个单一字符
		.*		// 表示零个或任意个字符
		^a		// 表示以a为首的行
		a$		// 表示以a为尾的行
<!--	\<good	// 表示以good开头的单词		-->
		Sh/>	// 表示以Sh结尾的单词
		[abc]	// 表示当前位置a、b或c
		[^abc]	// 表示除了a、b、c以外的字符
		a*		// 表示空、a、aa、aaa、乃至更多个a
		a?		// 表示一个或零个单独的a
		a+		// 表示a、aa、aaa乃至更多个a（和a*的区别在于“空”）
		a\{n\}	// 表示重复了n次的a
</正则表达式>

<常识知识>
	Linux 工具/命令分为3种:
		1)<过滤器 notes="能够接受数据,过滤再输出的工具,成为过滤器"></过滤器>
		2)<编辑器/>
		3)<交互式的工具/>
	/proc文件系统:(这个是重点,需要再次学习)
		/proc 文件系统是一种内核和内核模块用来向进程(process) 发送信息的机制(所以叫做/proc)。
		这个伪文件系统让你可以和内核内部数据结构进行交互，
		获取有关进程的有用信息，在运行中(on the fly) 改变设置(通过改变内核参数)。
		与其他文件系统不同，/proc 存在于内存之中而不是硬盘上。

	常见的系统日志在:/var/log目录下==常用日志:
		/var/log/dmesg		// 核心启动日志
		/var/log/messages	// 系统报错日志
		/var/log/maillog	// E-mail邮件系统日志
		/var/log/boot.log	// 系统引导过程日志
		/var/log/cron		// 记录守护进程派生子进程
		/var/log/syslog		// 记录警告信息
		/var/log/wtmp		// 永久记录用户登录事件
		/var/log/xferlog	// 记录FTP会话
		/var/log/secure		// 安全信息

	终端设备：
		1)tty	// 表示终端设备,这是实际上的(显示器)
		2)pty	// 表示虚拟终端设备,主要是当远程登录使用的终端

***********************************************************************************

	<快捷键>
		Tab		// 自动补完命令行与文件命
		Tab键双击可以列出所有匹配的选择
		Ctrl + c 	// 结束当前的任务
		Ctrl + z 	// 任务暂停,并放在后台
		Ctrl + s	// 停止屏幕输出
		Ctrl + q	// 恢复屏幕输出
		Ctrl + l	// 清屏
		Ctrl + d 	// 标准输入结束
		Ctrl + r	// 调用命令历史
	</快捷键>

	<Linux的启动过程>
		Linux系统的初始化包含内核部分和init程序部分
			内核部分主要完成对系统硬件的检测和初始化工作
			init程序则主要完成对系统的各项配置

		启动过程分为以下几个阶段：
			1、执行GRUB或LILO引导转载程序
				开启电源后，计算机首先加载BIOS，并且检查基本的硬件信息，例如内存数量、处理器及硬盘容量等。
				然后，根据BIOS中的系统引导顺序，依次查找系统引导设备，读取并执行其MBR上的操作系统的引导装载程序，
				Linux上的引导装载程序有GRUB和LILO两种，在系统安装过程上由用户选择。
				该程序的主要功能就是指示系统在启动之后要加载那个系统，以及到何处加载。

			2、加载Linux内核
				如果选择启动Linux，系统就会从/boot分区读取并加载Linux内核程序，从此时开始正式进入Linux的控制。
				Linux首先会搜索系统中的所有硬件设备并驱动它们，同时这些硬件设备信息也会在屏幕上显示出来，
				用户可以借此了解硬件设备是否都成功驱动。
				也可以在开机后，打开/var/log/dmesg文件来检查所有的开机信息

			3、执行/sbin/init
				在系统加载Linux内核之后，紧接着会调用/sbin/init程序，以启动系统的init进程。
				该进程是Linux系统中的第一个进程，其进程号（PID）始终为1，它的工作是装载所有其他进程，是其他进程的父进程。
				init程序不仅启动和维护属于它自己的几个进程，它还调用其他几个包含了运行各种不同进程的脚本（script）的文件

			4、读取并执行/etc/inittab
				init程序首先读入/etc/inittab文件，根据/etc/inittab文件的内容决定系统启动为哪个运行级别，
				进而又/etc/init/rcS.conf、/etc/init/rc.conf等文件决定启动哪些服务程序

			5、执行/etc/rc.d/rc/local脚本程序
				/etc/rc.d/rc.local程序相当于MS-DOS系统中的autoexec.bat文件，在此文件中可加入每次开机时要执行的若干程序或命令名称，
				每个程序或命令占一行，系统将按顺序执行。默认要执行的命令是：
					[...]# touch /var/lock/subsys/local

			6、执行/bin/login登陆程序
				如以上步骤都正确无误，系统会依照指定的运行级别打开图形或字符的登陆界面，提示用户输入账号及口令，并进行验证。
				如果验证通过，系统就会为用户进行环境的初始化，然后将控制权交给Shell

	</Linux的启动过程>

	<进程和作业>
		<进程 notes="指具有独立功能的程序的一次运行过程">
			1、概念
				Linux是一个多用户多任务的操作系统，在同一时间允许有许多用户向操作系统发出各种操作命令。
				每当运行一个命令时，系统就会同时启动一个进程，
				进程（processes）是指具有独立功能的程序的一次运行过程，也是系统资源分配和调度的基本单位

				进程由程序产生，是一个运行着的、要占用系统资源的程序。
				但进程并不等于程序，进程是动态的，而程序是静态的文件，多个进程可以并发调用同一个程序，一个程序可以启动多个进程。
				当程序被系统调用内存以后，系统会给程序分配一定的资源（如内存、设备等），然后进行一系列的复杂操作，使程序变成进程以供系统调用。
				为了区分不同的进程，系统给每一个进程分配了一个唯一的进程标识符（PID）或进程号。

				Linux系统在刚刚启动时，运行于内核方式，此时只有一个初始化进程在运行，该进程首先对系统进行初始化，然后执行初始化程序（即/sbin/init）。
				初始化进程是系统的第一个进程，以后的所有进程都是初始化进程的子进程。在Shell下执行程序时启动的进程就是Shell进程的子进程。
				一般情况下，只有子进程结束后，才能继续父进程，若是从后台启动的，则不同等待子进程结束

			2、进程的状态
				为了充分利用系统资源，Linux系统将进程为以下几种状态：

				(1)、运行状态：进程正在使用CPU运行的状态。处于运行态的进程又称为当前进程（current process）
				(2)、就绪状态：进程已获得除CPU外运行所需的全部资源，一旦系统把CPU分配给它之后即可投入运行。
				(3)、等待状态：又称睡眠状态，进程正在等待某个事件或某个资源。
				(4)、休眠状态：进程主动暂时停止运行
				(5)、僵死状态：进程的运行已经结束，但它的控制信息仍在系统中
				(6)、终止状态：进程已经结束，系统正在回收资源

			3、进程的类型
				Linux系统的进程大体可分为交互进程、批处理进程和守护进程3种

				(1)、交互进程：由Shell通过执行程序所产生的进程，可以工作在前后台
				(2)、批处理进程：不需要与终端相关，是一个进程序列
				(3)、守护进程：Linux系统自动启动，工作在后台，用于监视特定服务

			4、进程的优先级
				在Linux操作系统中，进程之间的竞争资源（如CPU和内存的占用）的关系。
				Linux内核采用优先数调度算法来为进程分配CPU。
				每个进程都有两个优先级值：静态值和动态值。
				静态优先级也称niceness，除非用户指定，否则不会改变。
				动态优先级合成priority，它以静态优先级为基础，决定了CPU处理进程的顺序，Linux内核会根据需要调整该数值的大小。
				通常讨论的优先级是指静态优先级，这是因为无法控制动态优先级。

				Linux中进程优先级（niceness）的取值范围是-20~19之间的整数，取值越高，优先级越低，默认为0
				启动进程的普通用户只能降低进程优先级，超级用户不但可以降低优先级，也可以提高优先级

			5、进程的启动
				(1)手工启动
					手工启动即由用户在Shell命令行下输入要执行的程序来启动一个进程.
					手工启动又可以分为前台启动和后台启动.用户输入Shell命令后直接按[Enter]键,则启动前台进程;
					如果在输入Shell命令后加上"&"符号在按[Enter]键,则启动后台进程,此时进程在后台运行,Shell可继续运行和处理其他程序
				(2)调度启动
					调度启动时指系统按照用户的事先设置,在特定的时间或者周期性地执行指定的进程.
					在对Linux系统进程维护和管理的过程中,有时需要进程一些比较费时而且占用资源较多的操作,为了不影响正常的服务,
					通常将其安排在深夜或者其他空闲时间由系统自动运行.
					此时在Linux中可以实现at调度、batch调度和cron调度

			6、Linux的进程管理 P106
				具体命令看-->[系统命令]模块

		</进程>
		<作业 notes="正在执行的一个或多个相关进程称为作业(任务)">
			正在执行的一个或多个相关进程称为作业也称任务。
			一个作业可以包含一个活多个进程，比如当使用了管道和重定向命令时，该作业就包含了多个进程。
			例如：
				[...]# cat file | wc -l

			在这个命令中,作业cat file | wc -l就同时启动了两个进程,它们分别是cat和wc.
			作业可以分为两类:前台作业和后台作业.
			前台作业运行于前台,与用户进行交互操作;
			后台作业运行于后台,不直接于用户交互,但可以输出执行结果.
			同一时刻,每一个用户只能有一个前台作业.

			在命令行的最后加入&符号,变为后台
		</作业>
	</进程和作业>

	<常用的配置文件>
		/usr/share/dict/words		// Linux系统当中的“字典”
		/etc/hosts					// <概述> Linux系统的(主机名查询静态表)linux的/etc/hosts是配置ip地址和其对应主机名的文件，
										这里可以记录本机的或其他主机的ip及其对应主机名。
										不同的linux版本，这个配置文件也可能不同。比如Debian的对应文件时/etc/hostname。</概述>
		/etc/sysconfig/network	// 可以永久更改主机名
		/etc/sysconfig/network-scripts/ifcfg-eth0	// 用于设置Linux的IP地址
		~/.bash_profile				// 这个文件是bash启动的初始化文件
	</常用的配置文件>

	<输出输入重定向和管道>

		>		// 输出重定向或直接创建文件 例如: cat /etc/passwd > /tmp/zrq.txt // 使用cat命令将passwd文件的内容读取并写入到/tmp.txt文件中
		2>		// 错误的输出重定向 例如: ls [一个不存在的filename] 当出现报错信息的时候,只能使用2>中各种重定向,>是正确的才可以用
		&>		// 不管是错误的还是对的信息都执行重定向写入
		(注意: > 和 2> 和 &> 重定向输出到的文件都是先清空其原本内容在将获得的内容写入,所以有时可以用来清空文件)
		>>		// 不执行清空功能的重定向(追加)

<!--	<		// 输入重定向 一般用于当过滤器命令不支持直接写入文件名的时候使用,(相当于直接写入内容) -->
				// 输入重定向是指命令(或可执行程序)的标准输入重定向到指定的文件中.
				// 也就是说,输入可以不来自键盘,而来自一个指定的文件.
				// 所以说,输入重定向主要用于改变一个命令的输入源,特别是改变那些需要大量输入的输入源
<!--	<<		// 用于输入重定向的时候在某个地方停止  例如: cat > [filename] << EEE // 之后就可以输入内容,不过当输入的内容有EEE的时候,就自动退出了 EEE的内容可以随便改	-->
				// 从当前文档输入 追加
<!--			// 使用"<<"让系统将一次键盘的全部输入,-->
				// 先送入虚拟的"当前文档",再一次性输入追加到文档尾部
				// `需要一堆字母,符号或字符串作为始终标识符
				// `选择任意符号作为起始终标示符

		|	// 可以将前一个命令的输入作为下一个命令的输入

		实例:
			// 统计/dev下有多少文件
			[...]# ls /dev/wc -l

			// 显示所有文件大小,并按从大到小排序
			[...]# du -a | sort -n -r

			// 显示/etc/文件夹下所有文件夹
			[...]# ls -l /etc | grep '^d'

			// 分屏显示内核信息
			[...]# dmesg | more
	</输出输入重定向和管道>

	<目录含义>
		1、/- 根
		每一个文件和目录从根目录开始。
		只有root用户具有该目录下的写权限。请注意，/root是root用户的主目录，这与/.不一样


		2、/bin中 - 用户二进制文件
		包含二进制可执行文件。
		在单用户模式下，你需要使用的常见Linux命令都位于此目录下。系统的所有用户使用的命令都设在这里。
		例如：ps、ls、ping、grep、cp

		3、/sbin目录 - 系统二进制文件
		就像/bin，/sbin同样也包含二进制可执行文件。
		但是，在这个目录下的linux命令通常由系统管理员使用，对系统进行维护。例如：iptables、reboot、fdisk、ifconfig、swapon命令

		4、/etc - 配置文件
		包含所有程序所需的配置文件。
		也包含了用于启动/停止单个程序的启动和关闭shell脚本。例如：/etc/resolv.conf、/etc/logrotate.conf
			hosts：设备名称（或域名）到ip地址的解析，相当于本地存在的dns功能。

		5、/dev - 设备文件
		包含设备文件。
		这些包括终端设备、USB或连接到系统的任何设备。例如：/dev/tty1、/dev/usbmon0

		6、/proc - 进程信息
		包含系统进程的相关信息。
		这是一个虚拟的文件系统，包含有关正在运行的进程的信息。例如：/proc/{pid}目录中包含的与特定pid相关的信息。
		这是一个虚拟的文件系统，系统资源以文本信息形式存在。例如：/proc/uptime

		7、/var - 变量文件
		var代表变量文件。
		这个目录下可以找到内容可能增长的文件。
		这包括 - 系统日志文件（/var/log）;包和数据库文件（/var/lib）;电子邮件（/var/mail）;打印队列（/var/spool）;锁文件（/var/lock）;多次重新启动需要的临时文件（/var/tmp）;

		8、/tmp - 临时文件
		包含系统和用户创建的临时文件。
		当系统重新启动时，这个目录下的文件都将被删除。

		9、/usr - 用户程序
		包含二进制文件、库文件、文档和二级程序的源代码。
		/usr/bin中包含用户程序的二进制文件。如果你在/bin中找不到用户二进制文件，到/usr/bin目录看看。例如：at、awk、cc、less、scp。
		/usr/sbin中包含系统管理员的二进制文件。如果你在/sbin中找不到系统二进制文件，到/usr/sbin目录看看。例如：atd、cron、sshd、useradd、userdel。
		/usr/lib中包含了/usr/bin和/usr/sbin用到的库。
		/usr/local中包含了从源安装的用户程序。例如，当你从源安装Apache，它会在/usr/local/apache2中。

		10、/home - HOME目录
		所有用户用home目录来存储他们的个人档案。
		例如：/home/john、/home/nikita

		11、/boot - 引导加载程序文件
		包含引导加载程序相关的文件。
		内核的initrd、vmlinux、grub文件位于/boot下。
		例如：initrd.img-2.6.32-24-generic、vmlinuz-2.6.32-24-generic

		12、/lib - 系统库
		包含支持位于/bin和/sbin下的二进制文件的库文件.
		库文件名为 ld*或lib*.so.*
		例如：ld-2.11.1.so，libncurses.so.5.7

		13、/opt - 可选的附加应用程序
		opt代表可选的。
		包含从个别厂商的附加应用程序。
		附加应用程序应该安装在/opt/或者/opt/的子目录下。

		14、/mnt - 挂载目录
		临时安装目录，系统管理员可以挂载文件系统。

		15、/media - 可移动媒体设备
		用于挂载可移动设备的临时目录。
		举例来说，挂载CD-ROM的/media/cdrom，挂载软盘驱动器的/media/floppy;

		16、/srv - 服务数据
		srv代表服务。
		包含服务器特定服务相关的数据。
		例如，/srv/cvs包含cvs相关的数据。
	</目录含义>

	<软件安装>

	</软件安装>

</常识知识>





进度:
shell编程-软件安装 24:04
